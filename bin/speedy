//!/usr/bin/env node --harmony
'use strict'

const argv = require('argv');
const fs = require('fs');
const net = require('net');
const spawn = require('child_process').spawn;
const path = require('path');

argv.option({
  'name': 'port',
  'short': 'p',
  'type': 'string',
  'description': 'port to bind to',
});

const args = argv.run(),
  port = parseInt(args.options.port || 3746),
  finRg = /^Finished '([^']+)'/;

function findGulpfile(dirname) {
  const gulpfile = path.join(dirname, 'gulpfile.js');
  if (fs.existsSync(gulpfile))
    return gulpfile;
  const parentPath = path.normalize(path.join(dirname, '..'));
  if (parentPath === dirname)
    throw Error('gulpfile not found');
  else 
    return findGulpfile(parentPath);
};

let gulpfile;
try {
  gulpfile = findGulpfile(process.cwd());
} catch (err) {
  console.log('gulpfile.js not found');
  process.exit(1);
}

function connect() {
  const finished = new Map();
  for(let task of args.targets) {
    finished.set(task, false);
  }

  const client = net.connect({port: port}, () => {
    client.write(JSON.stringify([
      0,
      {
        type: 'start-tasks',
        args: args.targets,
        silent: false,
        gulpfile: gulpfile,
      }
    ]));
  });

  client.on('data', (msg) => {
    let parsed;
    try {
      parsed  = JSON.parse(msg.toString()); 
    } catch (err) {
      console.error(err);
      console.error(err.stack);
    }
    const data = parsed[1];
    console.log(data.data);

    let match = finRg.exec(data.data);
    if (match && finished.has(match[1]))
      finished.set(match[1], true);
    for(let v of finished.values()) {
      if (!v) return;
    }
    client.end();
    process.exit(0);
  });
  return client;
}

let client = connect();
client.on('error', (err) => {
  if (err.code === 'ECONNREFUSED') {
    console.log('starting gulp-server on port ' + port);
    const gsPath = path.normalize(path.join(__dirname, '../scripts/gulp-server.js'));
    spawn('node', ['--harmony', gsPath, '--port='+port], {detached: true});
    setTimeout(connect, 1000);
  }
});

// vim: ft=javascript
